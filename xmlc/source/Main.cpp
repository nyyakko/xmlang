#include "codegen/Assembler.hpp"
#include "codegen/Compiler.hpp"
#include "Lexer.hpp"
#include "Parser.hpp"

#include <argparse/argparse.hpp>
#include <fmt/format.h>
#include <libenum/Enum.hpp>
#include <liberror/Result.hpp>
#include <liberror/Try.hpp>

#include <filesystem>
#include <fstream>

using namespace liberror;

Result<void> safe_main(std::span<char const*> arguments)
{
    argparse::ArgumentParser cli("xmlc", "", argparse::default_arguments::help);
    cli.add_description("xmlc compiler");

    cli.add_argument("-f", "--file").help("file to be compiled").required();
    cli.add_argument("-o", "--output").help("name of the generated bytecode file");

    argparse::ArgumentParser dump("dump", "", argparse::default_arguments::help);
    dump.add_description("dumps the result of a module to the standard output");

    auto& group = dump.add_mutually_exclusive_group(true);

    group.add_argument("-t", "--tokens").flag();
    group.add_argument("-a", "--ast").flag();
    group.add_argument("-s", "--asm").flag();

    cli.add_subparser(dump);

    try
    {
        cli.parse_args(static_cast<int>(arguments.size()), arguments.data());
    }
    catch (std::exception const& exception)
    {
        return liberror::make_error(exception.what());
    }

    auto source = cli.get<std::string>("--file");

    if (!std::filesystem::exists(source))
    {
        return make_error("source {} does not exist.", source);
    }

    auto tokens = tokenize(source);

    if (dump["--tokens"] != false)
    {
        std::cout << std::setw(4) << dump_tokens(tokens) << '\n';
        return {};
    }

    auto ast = TRY(parse(tokens));

    if (dump["--ast"] != false)
    {
        std::cout << std::setw(4) << dump_ast(ast) << '\n';
        return {};
    }

    auto assembly = TRY(compile(ast));

    if (dump["--asm"] != false)
    {
        std::cout << assembly << '\n';
        return {};
    }

    auto program = TRY(assemble(assembly));

    std::string output = [&] { return cli.has_value("--output") ? cli.get<std::string>("--output") : "program"; }();
    std::ofstream stream(fmt::format("{}.kubo", output), std::ios::binary);
    stream.write(reinterpret_cast<char const*>(program.data()), static_cast<int>(program.size()));

    return {};
}

int main(int argc, char const** argv)
{
    auto result = safe_main(std::span<char const*>(argv, size_t(argc)));

    if (!result.has_value())
    {
        std::cout << result.error().message() << '\n';
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
